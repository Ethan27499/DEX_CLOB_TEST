================================================================================
                     ORBITAL AMM - TECHNICAL IMPLEMENTATION GUIDE
                              Code Examples & Architecture
================================================================================

I. CORE SMART CONTRACT ARCHITECTURE
===================================

// 1. Main Orbital AMM Contract
contract OrbitalAMM {
    struct Pool {
        address[] tokens;
        uint256[] reserves;
        uint256[] weights;
        uint256 amplification;
        uint256 totalSupply;
        bool[] isolated;
        mapping(address => uint256) lpBalances;
    }
    
    mapping(bytes32 => Pool) public pools;
    mapping(address => bool) public authorizedOracles;
    
    function createPool(
        address[] memory tokens,
        uint256[] memory weights,
        uint256 amplification
    ) external returns (bytes32 poolId);
    
    function addLiquidity(
        bytes32 poolId,
        uint256[] memory amounts,
        uint256 minLPTokens
    ) external returns (uint256 lpTokens);
    
    function swap(
        bytes32 poolId,
        address tokenIn,
        address tokenOut,
        uint256 amountIn,
        uint256 minAmountOut
    ) external returns (uint256 amountOut);
    
    function getSwapQuote(
        bytes32 poolId,
        address tokenIn,
        address tokenOut,
        uint256 amountIn
    ) external view returns (uint256 amountOut, uint256 priceImpact);
}

// 2. Depeg Risk Manager
contract DepegManager {
    struct AssetState {
        uint256 lastPrice;
        uint256 priceDeviation;
        uint256 deviationDuration;
        bool isIsolated;
        uint256 isolationTimestamp;
    }
    
    mapping(address => AssetState) public assetStates;
    
    uint256 public constant DEPEG_THRESHOLD = 200; // 2%
    uint256 public constant ISOLATION_DURATION = 300; // 5 minutes
    
    function checkDepeg(address asset) external {
        uint256 currentPrice = getOraclePrice(asset);
        uint256 deviation = calculateDeviation(currentPrice, 1e18);
        
        if (deviation > DEPEG_THRESHOLD) {
            AssetState storage state = assetStates[asset];
            
            if (state.priceDeviation < DEPEG_THRESHOLD) {
                state.deviationDuration = block.timestamp;
            }
            
            state.priceDeviation = deviation;
            
            if (block.timestamp - state.deviationDuration > ISOLATION_DURATION) {
                isolateAsset(asset);
            }
        } else {
            resetAssetState(asset);
        }
    }
    
    function isolateAsset(address asset) internal {
        assetStates[asset].isIsolated = true;
        assetStates[asset].isolationTimestamp = block.timestamp;
        
        // Notify all pools to isolate this asset
        emit AssetIsolated(asset, block.timestamp);
    }
}

// 3. Multi-Asset Math Library
library OrbitalMath {
    using SafeMath for uint256;
    
    // Calculate multi-asset invariant: k = Π(xᵢ^wᵢ)
    function calculateInvariant(
        uint256[] memory reserves,
        uint256[] memory weights
    ) internal pure returns (uint256) {
        require(reserves.length == weights.length, "Length mismatch");
        
        uint256 invariant = 1e18;
        for (uint256 i = 0; i < reserves.length; i++) {
            if (reserves[i] > 0) {
                invariant = invariant.mul(
                    pow(reserves[i], weights[i])
                ).div(1e18);
            }
        }
        return invariant;
    }
    
    // Calculate optimal swap amount
    function calculateSwapAmount(
        uint256 reserveIn,
        uint256 reserveOut,
        uint256 weightIn,
        uint256 weightOut,
        uint256 amountIn,
        uint256 fee
    ) internal pure returns (uint256) {
        uint256 adjustedAmountIn = amountIn.mul(10000 - fee).div(10000);
        
        // Simplified formula: amountOut = reserveOut * (1 - (reserveIn / (reserveIn + adjustedAmountIn))^(weightIn/weightOut))
        uint256 ratio = reserveIn.add(adjustedAmountIn).mul(1e18).div(reserveIn);
        uint256 weightRatio = weightIn.mul(1e18).div(weightOut);
        uint256 powRatio = pow(ratio, weightRatio).div(1e18);
        
        return reserveOut.mul(1e18 - powRatio).div(1e18);
    }
    
    // Power function implementation (simplified)
    function pow(uint256 base, uint256 exp) internal pure returns (uint256) {
        // Simplified power function - use proper implementation
        uint256 result = 1e18;
        for (uint256 i = 0; i < exp; i++) {
            result = result.mul(base).div(1e18);
        }
        return result;
    }
}

II. BACKEND INTEGRATION CODE
============================

// TypeScript Integration với existing codebase

// 1. Orbital AMM Service
export class OrbitalAMMService {
    private logger: Logger;
    private contract: ethers.Contract;
    private oraclePriceService: OraclePriceService;
    
    constructor(
        contractAddress: string,
        provider: ethers.Provider,
        oraclePriceService: OraclePriceService
    ) {
        this.logger = new Logger('OrbitalAMMService');
        this.contract = new ethers.Contract(contractAddress, ORBITAL_ABI, provider);
        this.oraclePriceService = oraclePriceService;
    }
    
    public async createStablecoinPool(
        tokens: string[],
        initialLiquidity: Record<string, bigint>
    ): Promise<string> {
        try {
            // Validate all tokens are stablecoins
            for (const token of tokens) {
                const price = await this.oraclePriceService.getPrice(token);
                if (Math.abs(price.price - 1.0) > 0.05) {
                    throw new Error(`Token ${token} not stable: $${price.price}`);
                }
            }
            
            // Calculate equal weights for stablecoins
            const weights = new Array(tokens.length).fill(
                BigInt(1e18) / BigInt(tokens.length)
            );
            
            const tx = await this.contract.createPool(tokens, weights, 100);
            const receipt = await tx.wait();
            
            const poolId = receipt.events.find(e => e.event === 'PoolCreated').args.poolId;
            
            this.logger.info('Stablecoin pool created', {
                poolId,
                tokens,
                weights
            });
            
            return poolId;
            
        } catch (error) {
            this.logger.error('Failed to create pool:', error);
            throw error;
        }
    }
    
    public async getOptimalSwapQuote(
        poolId: string,
        tokenIn: string,
        tokenOut: string,
        amountIn: bigint
    ): Promise<SwapQuote> {
        try {
            const [amountOut, priceImpact] = await this.contract.getSwapQuote(
                poolId,
                tokenIn,
                tokenOut,
                amountIn
            );
            
            return {
                amountOut: BigInt(amountOut.toString()),
                priceImpact: Number(priceImpact.toString()) / 10000,
                route: [tokenIn, tokenOut],
                gasEstimate: 250000n
            };
            
        } catch (error) {
            this.logger.error('Failed to get quote:', error);
            throw error;
        }
    }
    
    public async executeSwap(
        poolId: string,
        tokenIn: string,
        tokenOut: string,
        amountIn: bigint,
        minAmountOut: bigint,
        userAddress: string
    ): Promise<SwapResult> {
        try {
            // Check for depeg before swap
            await this.checkAssetHealth(tokenIn);
            await this.checkAssetHealth(tokenOut);
            
            const tx = await this.contract.swap(
                poolId,
                tokenIn,
                tokenOut,
                amountIn,
                minAmountOut
            );
            
            const receipt = await tx.wait();
            
            return {
                txHash: receipt.transactionHash,
                amountOut: receipt.events.find(e => e.event === 'Swap').args.amountOut,
                gasUsed: receipt.gasUsed,
                timestamp: Date.now()
            };
            
        } catch (error) {
            this.logger.error('Swap failed:', error);
            throw error;
        }
    }
    
    private async checkAssetHealth(token: string): Promise<void> {
        const price = await this.oraclePriceService.getPrice(token);
        
        if (Math.abs(price.price - 1.0) > 0.02) {
            throw new Error(`Asset ${token} potentially depegged: $${price.price}`);
        }
    }
}

// 2. Enhanced Routes trong Express server
export class OrbitalRoutes {
    private orbitalService: OrbitalAMMService;
    
    constructor(orbitalService: OrbitalAMMService) {
        this.orbitalService = orbitalService;
    }
    
    public setupRoutes(app: express.Application): void {
        // Create new stablecoin pool
        app.post('/api/v1/orbital/pools', async (req, res) => {
            try {
                const { tokens, initialLiquidity } = req.body;
                
                const poolId = await this.orbitalService.createStablecoinPool(
                    tokens,
                    initialLiquidity
                );
                
                res.json({
                    success: true,
                    poolId,
                    message: 'Pool created successfully'
                });
                
            } catch (error) {
                res.status(500).json({
                    error: 'Failed to create pool',
                    message: error.message
                });
            }
        });
        
        // Get swap quote
        app.get('/api/v1/orbital/quote', async (req, res) => {
            try {
                const { poolId, tokenIn, tokenOut, amountIn } = req.query;
                
                const quote = await this.orbitalService.getOptimalSwapQuote(
                    poolId as string,
                    tokenIn as string,
                    tokenOut as string,
                    BigInt(amountIn as string)
                );
                
                res.json({
                    success: true,
                    quote: {
                        amountOut: quote.amountOut.toString(),
                        priceImpact: quote.priceImpact,
                        route: quote.route,
                        gasEstimate: quote.gasEstimate.toString()
                    }
                });
                
            } catch (error) {
                res.status(500).json({
                    error: 'Failed to get quote',
                    message: error.message
                });
            }
        });
        
        // Execute swap
        app.post('/api/v1/orbital/swap', async (req, res) => {
            try {
                const {
                    poolId,
                    tokenIn,
                    tokenOut,
                    amountIn,
                    minAmountOut,
                    userAddress
                } = req.body;
                
                const result = await this.orbitalService.executeSwap(
                    poolId,
                    tokenIn,
                    tokenOut,
                    BigInt(amountIn),
                    BigInt(minAmountOut),
                    userAddress
                );
                
                res.json({
                    success: true,
                    transaction: result
                });
                
            } catch (error) {
                res.status(500).json({
                    error: 'Swap failed',
                    message: error.message
                });
            }
        });
    }
}

III. DATABASE SCHEMA EXTENSIONS
===============================

-- Add Orbital AMM tables to existing schema

-- Pools table
CREATE TABLE orbital_pools (
    id SERIAL PRIMARY KEY,
    pool_id VARCHAR(66) UNIQUE NOT NULL,
    tokens TEXT[] NOT NULL,
    reserves DECIMAL[] NOT NULL,
    weights DECIMAL[] NOT NULL,
    amplification INTEGER NOT NULL,
    total_supply DECIMAL NOT NULL DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- LP Positions table
CREATE TABLE orbital_positions (
    id SERIAL PRIMARY KEY,
    pool_id VARCHAR(66) NOT NULL,
    user_address VARCHAR(42) NOT NULL,
    lp_tokens DECIMAL NOT NULL,
    token_amounts DECIMAL[] NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (pool_id) REFERENCES orbital_pools(pool_id)
);

-- Swaps table
CREATE TABLE orbital_swaps (
    id SERIAL PRIMARY KEY,
    pool_id VARCHAR(66) NOT NULL,
    user_address VARCHAR(42) NOT NULL,
    token_in VARCHAR(42) NOT NULL,
    token_out VARCHAR(42) NOT NULL,
    amount_in DECIMAL NOT NULL,
    amount_out DECIMAL NOT NULL,
    price_impact DECIMAL NOT NULL,
    fee_paid DECIMAL NOT NULL,
    tx_hash VARCHAR(66) NOT NULL,
    block_number INTEGER NOT NULL,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (pool_id) REFERENCES orbital_pools(pool_id)
);

-- Asset isolation events
CREATE TABLE asset_isolations (
    id SERIAL PRIMARY KEY,
    asset_address VARCHAR(42) NOT NULL,
    pool_id VARCHAR(66) NOT NULL,
    trigger_price DECIMAL NOT NULL,
    deviation_percent DECIMAL NOT NULL,
    isolated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    restored_at TIMESTAMP NULL,
    reason TEXT,
    FOREIGN KEY (pool_id) REFERENCES orbital_pools(pool_id)
);

-- Indexes for performance
CREATE INDEX idx_orbital_pools_tokens ON orbital_pools USING GIN(tokens);
CREATE INDEX idx_orbital_positions_user ON orbital_positions(user_address);
CREATE INDEX idx_orbital_positions_pool ON orbital_positions(pool_id);
CREATE INDEX idx_orbital_swaps_pool ON orbital_swaps(pool_id);
CREATE INDEX idx_orbital_swaps_user ON orbital_swaps(user_address);
CREATE INDEX idx_orbital_swaps_timestamp ON orbital_swaps(timestamp);
CREATE INDEX idx_asset_isolations_asset ON asset_isolations(asset_address);

IV. FRONTEND INTEGRATION EXAMPLES
=================================

// React Component for Orbital Swap Interface

import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';

interface SwapComponentProps {
    userAddress: string;
    provider: ethers.Provider;
}

export const OrbitalSwapComponent: React.FC<SwapComponentProps> = ({
    userAddress,
    provider
}) => {
    const [pools, setPools] = useState<Pool[]>([]);
    const [selectedPool, setSelectedPool] = useState<string>('');
    const [tokenIn, setTokenIn] = useState<string>('');
    const [tokenOut, setTokenOut] = useState<string>('');
    const [amountIn, setAmountIn] = useState<string>('');
    const [quote, setQuote] = useState<SwapQuote | null>(null);
    const [loading, setLoading] = useState<boolean>(false);
    
    // Load available pools
    useEffect(() => {
        loadPools();
    }, []);
    
    const loadPools = async () => {
        try {
            const response = await fetch('/api/v1/orbital/pools');
            const data = await response.json();
            setPools(data.pools);
        } catch (error) {
            console.error('Failed to load pools:', error);
        }
    };
    
    // Get swap quote when inputs change
    useEffect(() => {
        if (selectedPool && tokenIn && tokenOut && amountIn) {
            getQuote();
        }
    }, [selectedPool, tokenIn, tokenOut, amountIn]);
    
    const getQuote = async () => {
        setLoading(true);
        try {
            const response = await fetch(
                `/api/v1/orbital/quote?poolId=${selectedPool}&tokenIn=${tokenIn}&tokenOut=${tokenOut}&amountIn=${ethers.parseUnits(amountIn, 18)}`
            );
            const data = await response.json();
            setQuote(data.quote);
        } catch (error) {
            console.error('Failed to get quote:', error);
        } finally {
            setLoading(false);
        }
    };
    
    const executeSwap = async () => {
        if (!quote) return;
        
        setLoading(true);
        try {
            const response = await fetch('/api/v1/orbital/swap', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    poolId: selectedPool,
                    tokenIn,
                    tokenOut,
                    amountIn: ethers.parseUnits(amountIn, 18).toString(),
                    minAmountOut: (BigInt(quote.amountOut) * 99n / 100n).toString(), // 1% slippage
                    userAddress
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                alert(`Swap successful! Tx: ${data.transaction.txHash}`);
                // Reset form
                setAmountIn('');
                setQuote(null);
            }
            
        } catch (error) {
            console.error('Swap failed:', error);
            alert('Swap failed: ' + error.message);
        } finally {
            setLoading(false);
        }
    };
    
    return (
        <div className="orbital-swap-container">
            <h2>Orbital Stablecoin Swap</h2>
            
            {/* Pool Selection */}
            <div className="pool-selector">
                <label>Select Pool:</label>
                <select value={selectedPool} onChange={(e) => setSelectedPool(e.target.value)}>
                    <option value="">Choose pool...</option>
                    {pools.map(pool => (
                        <option key={pool.id} value={pool.id}>
                            {pool.tokens.join('/')} Pool
                        </option>
                    ))}
                </select>
            </div>
            
            {/* Token Input */}
            <div className="token-input">
                <label>From:</label>
                <select value={tokenIn} onChange={(e) => setTokenIn(e.target.value)}>
                    <option value="">Select token...</option>
                    <option value="USDC">USDC</option>
                    <option value="USDT">USDT</option>
                    <option value="DAI">DAI</option>
                </select>
                <input
                    type="number"
                    value={amountIn}
                    onChange={(e) => setAmountIn(e.target.value)}
                    placeholder="Amount"
                />
            </div>
            
            {/* Token Output */}
            <div className="token-output">
                <label>To:</label>
                <select value={tokenOut} onChange={(e) => setTokenOut(e.target.value)}>
                    <option value="">Select token...</option>
                    <option value="USDC">USDC</option>
                    <option value="USDT">USDT</option>
                    <option value="DAI">DAI</option>
                </select>
                {quote && (
                    <div className="quote-display">
                        <span>≈ {ethers.formatUnits(quote.amountOut, 18)}</span>
                        <span>Price Impact: {(quote.priceImpact * 100).toFixed(2)}%</span>
                    </div>
                )}
            </div>
            
            {/* Swap Button */}
            <button
                onClick={executeSwap}
                disabled={!quote || loading}
                className="swap-button"
            >
                {loading ? 'Processing...' : 'Swap'}
            </button>
            
            {/* Pool Stats */}
            {selectedPool && (
                <div className="pool-stats">
                    <h3>Pool Statistics</h3>
                    <p>TVL: $1.2M</p>
                    <p>24h Volume: $45K</p>
                    <p>APR: 8.5%</p>
                </div>
            )}
        </div>
    );
};

V. DEPLOYMENT SCRIPTS
=====================

// Hardhat deployment script

import { ethers, run } from 'hardhat';

async function main() {
    console.log('Deploying Orbital AMM contracts...');
    
    // Deploy Oracle Aggregator first
    const OracleAggregator = await ethers.getContractFactory('OracleAggregator');
    const oracleAggregator = await OracleAggregator.deploy();
    await oracleAggregator.deployed();
    console.log('OracleAggregator deployed to:', oracleAggregator.address);
    
    // Deploy Depeg Manager
    const DepegManager = await ethers.getContractFactory('DepegManager');
    const depegManager = await DepegManager.deploy(oracleAggregator.address);
    await depegManager.deployed();
    console.log('DepegManager deployed to:', depegManager.address);
    
    // Deploy main Orbital AMM
    const OrbitalAMM = await ethers.getContractFactory('OrbitalAMM');
    const orbitalAMM = await OrbitalAMM.deploy(
        oracleAggregator.address,
        depegManager.address
    );
    await orbitalAMM.deployed();
    console.log('OrbitalAMM deployed to:', orbitalAMM.address);
    
    // Set up initial stablecoin pool
    const stablecoins = [
        '0xA0b86a33E6441c641ea4d5b69Bff991fc35E8E87', // USDC
        '0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9', // USDT  
        '0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1'  // DAI
    ];
    
    const weights = [
        ethers.parseEther('0.333'),
        ethers.parseEther('0.333'),
        ethers.parseEther('0.334')
    ];
    
    const poolTx = await orbitalAMM.createPool(stablecoins, weights, 100);
    const poolReceipt = await poolTx.wait();
    const poolId = poolReceipt.events?.find(e => e.event === 'PoolCreated')?.args?.poolId;
    
    console.log('Initial stablecoin pool created:', poolId);
    
    // Verify contracts on Etherscan
    if (process.env.ETHERSCAN_API_KEY) {
        console.log('Verifying contracts...');
        
        await run('verify:verify', {
            address: oracleAggregator.address,
            constructorArguments: []
        });
        
        await run('verify:verify', {
            address: depegManager.address,
            constructorArguments: [oracleAggregator.address]
        });
        
        await run('verify:verify', {
            address: orbitalAMM.address,
            constructorArguments: [oracleAggregator.address, depegManager.address]
        });
        
        console.log('Contracts verified!');
    }
    
    // Save deployment info
    const deploymentInfo = {
        network: (await ethers.provider.getNetwork()).name,
        contracts: {
            OracleAggregator: oracleAggregator.address,
            DepegManager: depegManager.address,
            OrbitalAMM: orbitalAMM.address
        },
        pools: {
            stablecoinPool: poolId
        },
        timestamp: new Date().toISOString()
    };
    
    const fs = require('fs');
    fs.writeFileSync(
        `deployment-${Date.now()}.json`,
        JSON.stringify(deploymentInfo, null, 2)
    );
    
    console.log('Deployment completed successfully!');
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });

VI. TESTING FRAMEWORK
=====================

// Comprehensive test suite

import { expect } from 'chai';
import { ethers } from 'hardhat';
import { OrbitalAMM, MockERC20 } from '../typechain';

describe('Orbital AMM', function () {
    let orbitalAMM: OrbitalAMM;
    let usdc: MockERC20;
    let usdt: MockERC20;
    let dai: MockERC20;
    let owner: any;
    let user1: any;
    let user2: any;
    
    beforeEach(async function () {
        [owner, user1, user2] = await ethers.getSigners();
        
        // Deploy mock tokens
        const MockERC20 = await ethers.getContractFactory('MockERC20');
        usdc = await MockERC20.deploy('USDC', 'USDC', 6);
        usdt = await MockERC20.deploy('USDT', 'USDT', 6);
        dai = await MockERC20.deploy('DAI', 'DAI', 18);
        
        // Deploy Orbital AMM
        const OrbitalAMM = await ethers.getContractFactory('OrbitalAMM');
        orbitalAMM = await OrbitalAMM.deploy();
        
        // Mint tokens to users
        await usdc.mint(user1.address, ethers.parseUnits('10000', 6));
        await usdt.mint(user1.address, ethers.parseUnits('10000', 6));
        await dai.mint(user1.address, ethers.parseEther('10000'));
    });
    
    describe('Pool Creation', function () {
        it('Should create a 3-asset stablecoin pool', async function () {
            const tokens = [usdc.address, usdt.address, dai.address];
            const weights = [
                ethers.parseEther('0.333'),
                ethers.parseEther('0.333'),
                ethers.parseEther('0.334')
            ];
            
            const tx = await orbitalAMM.createPool(tokens, weights, 100);
            const receipt = await tx.wait();
            
            expect(receipt.events?.length).to.be.greaterThan(0);
            
            const poolCreatedEvent = receipt.events?.find(e => e.event === 'PoolCreated');
            expect(poolCreatedEvent).to.not.be.undefined;
        });
    });
    
    describe('Liquidity Operations', function () {
        let poolId: string;
        
        beforeEach(async function () {
            const tokens = [usdc.address, usdt.address, dai.address];
            const weights = [
                ethers.parseEther('0.333'),
                ethers.parseEther('0.333'),
                ethers.parseEther('0.334')
            ];
            
            const tx = await orbitalAMM.createPool(tokens, weights, 100);
            const receipt = await tx.wait();
            poolId = receipt.events?.find(e => e.event === 'PoolCreated')?.args?.poolId;
        });
        
        it('Should add initial liquidity', async function () {
            const amounts = [
                ethers.parseUnits('1000', 6), // USDC
                ethers.parseUnits('1000', 6), // USDT
                ethers.parseEther('1000')     // DAI
            ];
            
            // Approve tokens
            await usdc.connect(user1).approve(orbitalAMM.address, amounts[0]);
            await usdt.connect(user1).approve(orbitalAMM.address, amounts[1]);
            await dai.connect(user1).approve(orbitalAMM.address, amounts[2]);
            
            const tx = await orbitalAMM.connect(user1).addLiquidity(
                poolId,
                amounts,
                0 // min LP tokens
            );
            
            await expect(tx).to.emit(orbitalAMM, 'LiquidityAdded');
        });
    });
    
    describe('Swap Operations', function () {
        let poolId: string;
        
        beforeEach(async function () {
            // Create pool and add liquidity
            const tokens = [usdc.address, usdt.address, dai.address];
            const weights = [
                ethers.parseEther('0.333'),
                ethers.parseEther('0.333'),
                ethers.parseEther('0.334')
            ];
            
            const createTx = await orbitalAMM.createPool(tokens, weights, 100);
            const createReceipt = await createTx.wait();
            poolId = createReceipt.events?.find(e => e.event === 'PoolCreated')?.args?.poolId;
            
            // Add initial liquidity
            const amounts = [
                ethers.parseUnits('10000', 6),
                ethers.parseUnits('10000', 6),
                ethers.parseEther('10000')
            ];
            
            await usdc.connect(user1).approve(orbitalAMM.address, amounts[0]);
            await usdt.connect(user1).approve(orbitalAMM.address, amounts[1]);
            await dai.connect(user1).approve(orbitalAMM.address, amounts[2]);
            
            await orbitalAMM.connect(user1).addLiquidity(poolId, amounts, 0);
        });
        
        it('Should swap USDC for USDT', async function () {
            const swapAmount = ethers.parseUnits('100', 6);
            await usdc.connect(user1).approve(orbitalAMM.address, swapAmount);
            
            const balanceBefore = await usdt.balanceOf(user1.address);
            
            await orbitalAMM.connect(user1).swap(
                poolId,
                usdc.address,
                usdt.address,
                swapAmount,
                0 // min amount out
            );
            
            const balanceAfter = await usdt.balanceOf(user1.address);
            expect(balanceAfter).to.be.greaterThan(balanceBefore);
        });
        
        it('Should calculate accurate swap quotes', async function () {
            const swapAmount = ethers.parseUnits('100', 6);
            
            const [amountOut, priceImpact] = await orbitalAMM.getSwapQuote(
                poolId,
                usdc.address,
                usdt.address,
                swapAmount
            );
            
            expect(amountOut).to.be.greaterThan(0);
            expect(priceImpact).to.be.lessThan(100); // Less than 1%
        });
    });
    
    describe('Depeg Protection', function () {
        // Test depeg detection and isolation
    });
});

================================================================================
                        IMPLEMENTATION READY CODE
================================================================================
